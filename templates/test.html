<!doctype html>
<html>
<style>
  .axis line,
  .axis circle {
    fill: none;
    stroke: #aaaaaa;
    /* stroke-dasharray: 1, 5; */
  }
</style>

<head>
  <!-- <script src="https://d3js.org/d3.v7.min.js"></script> -->
  <script src="https://d3js.org/d3.v4.js"></script>
  <script src="js/demo/muzz.js"></script>
  <style>
  </style>
</head>

<body>
  <div id="mydiv">
    <h2 id="myadd">Test workspace...</h2>
  </div>
  <!-- <svg viewBox="0 0 1010 666" id="myViz1"> </svg> -->
  <svg id="myViz2" width=1000 height=500></svg>
  <h2> Polar chart for a single participant over the entire study period</h2>
  <svg id="myViz1" width=600 height=600></svg>

  <!-- Script 1 for #myViz1 -->
  <script>
    var svg = d3.select('#myViz1')
    // set the dimensions and margins of the graph
    const width = Math.floor(svg.style("width").replace('px', ''));
    const height = Math.floor(svg.style("height").replace('px', ''));
    const margin = 0


    // append the svg object to the div called 'my_dataviz'
    // var svg = d3.select("#myViz1")
    //   .attr("width", width)
    //   .attr("height", height)
    //   .append("g")
    //   .attr("transform", "translate(" + (radius + margin / 2) + "," + (radius + margin / 2) + ")");



    function create_pie(data, level, i_count) {
      innerRadius = radius * level * 0.2
      outerRadius = radius * (level * 0.2 + 0.2)

      //x and y axis scales
      var y = d3.scaleBand()
        .range([0, height])
        .domain(d3.range(numRows));

      var x = d3.scaleBand()
        .range([0, width])
        .domain(d3.range(numCols));

      // set the color scale
      var color = d3.scaleOrdinal()
        .domain(data)
        .range(["#98abc5", "#8a89a6", "#7b6888", "#6b486b", "#a05d56"])

      // Compute the position of each group on the pie:
      var pie = d3.pie()
        .value(function (d) { return d.value; })

      var data_ready = pie(d3.entries(data))

      // console.log("Muzz", i_count, (Math.floor(i_count / numCols) * 2 + 1), (i_count % numCols) * 2 + 1)
      // .attr('cx', function(d,i){return x(i%numCols);})
      // .attr('cy', function(d,i){return y(Math.floor(i/numCols));})
      // Build the pie chart: Basically, each part of the pie is a path that we build using the arc function.
      svg
        .selectAll('whatever')
        .data(data_ready)
        .enter()
        .append('path')
        .attr('d', d3.arc()
          .innerRadius(innerRadius)
          .outerRadius(outerRadius)
        )
        .attr("transform", "translate(" + (((i_count % numCols) * 2 + 1) * radius) + "," + ((Math.floor(i_count / numCols) * 2 + 1) * radius) + ")")
        .attr('fill', function (d) { return (color(d.data.key)) })
        .attr("stroke", "black")
        .style("stroke-width", "1px")
        .style("opacity", 0.7)

      // if (icount % 2 == 0) { }con
      console.log(i_count, i_count % numRows, "Pixel5")

    }

    //rows and columns for the grid
    const count = 450
    //#######change this hard coded value
    radius = Math.sqrt((0.7 * width * height) / (count)) / 2
    // radius = Math.floor(Math.sqrt(Math.floor(width * height / 3.14 / count)) - 2)
    const numRows = Math.floor(height / (2.5 * radius));
    const numCols = Math.floor(width / (2.5 * radius));
    // var numRows = Math.floor(Math.sqrt(count))
    // var numCols = Math.ceil(Math.sqrt(count))
    // var radius = (height / numRows / 1.5)

    // The radius of the pieplot is half the width or half the height (smallest one). I subtract a bit of margin.
    // var radius = (Math.min(width, height) - margin) / 2 / count
    console.log("width, height, margin, radius, count, numRows, numCols", width, height, margin, radius, count, numRows, numCols)

    for (let i = 0; i < count; i++) {
      var data = { a: 5, b: 2, c: 1, d: 3 }
      // create_pie(data, 1, i)

      var data = { a: 1, b: 1, c: 10, d: 1, e: 5, f: 1, g: 1, h: 1, i: 1, j: 1, k: 1, l: 1, m: 1, n: 1, o: 1, p: 1, q: 1, r: 1, s: 1, t: 1, u: 1, v: 1, w: 1, x: 1 }
      create_pie(data, 4, i)

      var data = { a: 1, b: 1, c: 1, d: 1, e: 1, f: 1, g: 1, h: 1, i: 1, j: 1, k: 1, l: 1, m: 1, n: 1, o: 1, p: 1, q: 1, r: 1, s: 1, t: 1, u: 1, v: 1, w: 1, x: 1 }
      create_pie(data, 3, i)

      var data = { a: 1, b: 1, c: 1, d: 1, e: 5 }
      create_pie(data, 2, i)

      var data = { a: 1, b: 1 }
      create_pie(data, 1, i)
    }

  </script>


  <!-- Script 1 for #myViz2 -->
  <script>
    // var colors = ["#d9d9d9", "#ffffb2", "#fecc5c", "#fd8d3c", "#e31a1c"]  //orange red
    var colors = ["#aaaaaa", "#e41a1c", "#377eb8", "#4daf4a", "#984ea3"]  //purple green
    // var colors = ["#d9d9d9", "#fdd0a2", "#fdae6b", "#f16913", "#d94801", "#7f2704"] //orange
    // var colors = ["#aaaaaa", "#bdbdbd", "#969696", "#525252", "#000000"] //black and white
    num_circles = 150
    dimensions = { width: 1000, height: 1000 }
    myArcGenerator = d3.arc()
      .innerRadius(d => d.radii - 1.3)
      .outerRadius(d => d.radii + 1.3)
      .startAngle(d => d.start)
      .endAngle(d => d.end)
      .cornerRadius(1)

    // myArcGenerator2 = d3.arc()
    //   .innerRadius(d => d.radii +3 - 1)
    //   .outerRadius(d => d.radii +3 + 1)
    //   .startAngle(d => d.start)
    //   .endAngle(d => d.end)
    //   .cornerRadius(1)
    gap = (450 - 100) / num_circles;
    radii = d3.range(450, 100, -gap);
    radii1 = radii.map((r, i) => { return r - 0.25 * gap })
    radii2 = radii.map((r, i) => { return r - 0.5 * gap })
    radii3 = radii.map((r, i) => { return r - 0.75 * gap })

    myAngleScale = d3.scaleLinear().domain([0, 24 * 60 * 60]).range([0, 2 * Math.PI])

    //make a little runif function like R
    function runif(min, max) {
      return (Math.random() * (max - min)) + min;
    }

    // rerun this cell to generate new data!
    // data = radii.concat(radii1).concat(radii2).concat(radii3).map((el, i) => {
    data0 = radii.map((el, i) => {
      var start = myAngleScale(runif(0, 24 * 60 * 60));
      return ({
        start: start,
        end: start + myAngleScale(runif(60 * 60, 60 * 60 * 6)),
        radii: el,
        rotation: (i % 2) === 0 ? -1 : 1,
      })
    });

    data1 = radii1.map((el, i) => {
      var start = myAngleScale(runif(0, 24 * 60 * 60 - 1));
      return ({
        start: start,
        end: start + myAngleScale(runif(60 * 60, 60 * 60 * 6)),
        radii: el,
        rotation: (i % 2) === 0 ? -1 : 1,
      })
    });

    data2 = radii2.map((el, i) => {
      var start = myAngleScale(runif(0, 24 * 60 * 60 - 1));
      return ({
        start: start,
        end: start + myAngleScale(runif(60 * 60, 60 * 60 * 6)),
        radii: el,
        rotation: (i % 2) === 0 ? -1 : 1,
      })
    });

    data3 = radii3.map((el, i) => {
      var start = myAngleScale(runif(0, 24 * 60 * 60 - 1));
      return ({
        start: start,
        end: start + myAngleScale(runif(60 * 60, 60 * 60 * 6)),
        radii: el,
        rotation: (i % 2) === 0 ? -1 : 1,
      })
    });
    var svg = d3.select('#myViz2')
      .attr("viewBox", [0, 0, dimensions.width, dimensions.height])
      .attr("style", "overflow:scroll;")

    radius = 450;
    var ga = svg.append("g")
      .attr("class", "a axis")
      .selectAll("g")
      .data(d3.range(0, 24, 1))
      .enter().append("g")
      // .attr("transform", function (d) { return "rotate(" + -d + ")"; });
      .attr('transform', function (d) { return `translate(500,500)rotate(${-90 + d * 360 / 24})` });// + 'rotate(' + function (d) { return d } + ')');


    ga.append("line")
      .attr("x1", 100 - gap / 8)
      .attr("x2", radius);

    ga.append("text")
      .attr("x", 95)
      .attr("dy", ".35em")
      .style("text-anchor", function (d) { return d < 270 && d > 90 ? "end" : null; })
      .attr("transform", function (d) { return "rotate(45)"; })
      .attr("transform", function (d) { return d < 270 && d > 90 ? "rotate(180 " + (radius + 6) + ",0)" : null; })
      // .text(function (d) { return d + "hrs"; });
      // .text(function (d) { return d == 0 ? "0" : (d == 6 ? "6" : (d == 12 ? "12" : (d == 18 ? "18" : "-"))); });
      .text(function (d) { return d % 6 == 0 ? "x" : "-"; });


    // create circles using each radius.
    svg.selectAll("circle")
      .data(data0)
      .enter().append("circle")
      .attr("fill", "none")
      .attr("stroke", colors[0])
      // .attr("stroke-dasharray", 1, 5)
      .attr("r", function (d) { return d.radii })
      .attr('transform', `translate(${dimensions.width / 2}, ${dimensions.height / 2})`)

    // svg.selectAll("circle[name=circle0]")
    //   .enter().append("circle")
    //   .attr("name", "circle0")
    //   .attr("fill", "none")
    //   .attr("stroke", colors[0])
    //   .attr("r", 450)
    //   .attr('transform', `translate(${dimensions.width / 2}, ${dimensions.height / 2})`)




    // now create the paths using our generator
    svg.selectAll("path[name=path0]")
      .data(data0)
      .enter()
      .append("path")
      .attr("name", "path0")
      .attr("class", "arc")
      .attr("d", myArcGenerator)
      .attr("fill", colors[4])
      .attr('transform', function (d, i) {
        // let's leverage Observables generators to rotate our arcs!
        // ...but I am curious how we'd do this without generators - maybe using .transtion()?
        return `translate(${dimensions.width / 2}, ${dimensions.height / 2})`
        // return `translate(${dimensions.width / 2}, ${dimensions.height / 2}) rotate(${rotation * d.rotation + i})`
      })

    svg.selectAll("path[name=path1]")
      .data(data1)
      .enter()
      .append("path")
      .attr("name", "path1")
      .attr("class", "arc")
      .attr("d", myArcGenerator)
      .attr("fill", colors[3])
      .attr('transform', function (d, i) {
        // let's leverage Observables generators to rotate our arcs!
        // ...but I am curious how we'd do this without generators - maybe using .transtion()?
        return `translate(${dimensions.width / 2}, ${dimensions.height / 2})`
        // return `translate(${dimensions.width / 2}, ${dimensions.height / 2}) rotate(${rotation * d.rotation + i})`
      })

    svg.selectAll("path[name=path2]")
      .data(data2)
      .enter()
      .append("path")
      .attr("name", "path2")
      .attr("class", "arc")
      .attr("d", myArcGenerator)
      .attr("fill", colors[2])
      .attr('transform', function (d, i) {
        // let's leverage Observables generators to rotate our arcs!
        // ...but I am curious how we'd do this without generators - maybe using .transtion()?
        return `translate(${dimensions.width / 2}, ${dimensions.height / 2})`
        // return `translate(${dimensions.width / 2}, ${dimensions.height / 2}) rotate(${rotation * d.rotation + i})`
      })

    svg.selectAll("path[name=path3]")
      .data(data3)
      .enter()
      .append("path")
      .attr("name", "path3")
      .attr("class", "arc")
      .attr("d", myArcGenerator)
      .attr("fill", colors[1])
      .attr('transform', function (d, i) {
        // let's leverage Observables generators to rotate our arcs!
        // ...but I am curious how we'd do this without generators - maybe using .transtion()?
        return `translate(${dimensions.width / 2}, ${dimensions.height / 2})`
        // return `translate(${dimensions.width / 2}, ${dimensions.height / 2}) rotate(${rotation * d.rotation + i})`
      })

    // return svg.node();
    // obj = new TimeSpiral();
    // obj
  </script>

  <!-- Script 3 for visualization 3 -->
  <!-- <script>
    chart2 = {
      const svg = d3.create("svg")
        .attr("width", diameter)
        .attr("viewBox", [0, 0, diameter, diameter])
        .style("max-width", "100%")
        .style("cursor", "default");

      // TimeSpiral needs getBBox()
      yield svg.node();

      const chart = new TimeSpiral(svg)
        .size([diameter, diameter])
        .style({
          align: options2.align,
          barWidth: options2.barwidth,
          rounded: options2.rounded,
          colorBy: options2.colorby,
          showTicks: options2.showTicks,
          tickInterval: "monthly"
        })
        .layers(+options2.layers)
        .palette(options2.colorby === "time" ? d3.schemeTableau10 : d3.interpolateBuPu)
        .field({ value: `new${options.field}` })
        .data(data("New York"))
        .render();

      return svg.node();
    }

  </script> -->


</body>

</html>